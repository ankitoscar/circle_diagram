# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jf4Y6d9_9hy0bUGm0I-xlzdKOJO0YVag
"""

import numpy as np 
import matplotlib.pyplot as plt

def perpendicular(x_val, y_val):
  slope = (y_val[1] - y_val[0])/(x_val[1] - x_val[0])
  q = (y_val[1] + y_val[0])/2 
  p = (x_val[1] + x_val[0])/2
  slope = -1/slope
  cy = -slope * p + q
  cx = p - q/ slope 
  return cx, cy, slope

def slope(x_val, y_val):
  return ((y_val[1]-y_val[0])/(x_val[1]-x_val[0]))

def base_circle_centre(m, y, c):
  return (y-c)/m

def circle_intersection(x_val, y_val, x1, y1, y0, r):  
  m0 = slope([x_val[0], x_val[1]], [y_val[0], y_val[1]])
  a = m0*(y0 - y1) - x1
  c = m0*m0 + 1
  b = np.sqrt(np.square(a)-(x1*x1 + (y0-y1)**2 - r*r)*c)
  xp1 = (-a + b)/c
  xp2 = (-a - b)/c
  if xp1 < xp2:
    xf = xp1
  else:
    xf = xp2
  yf = m0*xf + y0
  deg = np.arccos(yf/np.sqrt(yf**2 + xf**2))*180/np.pi
  return xf, yf, deg

def plot_circle_diagram(ax, i_A=11, i_B=100, pfA=0.2, pfB=0.4, w_o=18920, w_sv=27172.17, scaler = 1, x=0.5):
  scaler = 1
  org = [0, 0]
  iA = np.array([i_A * (np.sqrt(1-np.square(pfA))), i_A * pfA]) / scaler
  iB = np.array([i_B * (np.sqrt(1-np.square(pfB))), i_B * pfB]) / scaler
  lim = 1.5 * np.sqrt(iB[0]**2 + iB[1]**2)
  ax.set_xlim([0, lim])
  ax.set_ylim([0, lim])
  ax.plot([org[0], iA[0]],[org[1], iA[1]])
  ax.plot([org[0], iB[0]],[org[1], iB[1]])
  ax.plot([iA[0], iB[0]],[iA[1], iB[1]])
  ax.annotate('O\'', (iA[0], iA[1]))
  ax.annotate('A', (iB[0], iB[1]))
  ax.axhline(y= iA[1], xmin=iA[0]/lim, xmax=1, linestyle=':')
  cx, cy, m = perpendicular([iA[0], iB[0]], [iA[1], iB[1]])
  ax.plot([0, cx], [cy, 0], linestyle="--")
  y1 = iA[1]
  x1 = cx * (1 - (y1/cy))
  theta = np.linspace(0, np.pi, 10000)
  r = x1 - iA[0]
  c = plt.Circle((x1, y1), radius= r, fill=False)
  ax.add_patch(c)
  ax.annotate('B', (iA[0]+2*r, iA[1]))
  ax.annotate('C', (x1, y1))
  ax.annotate('D', (iB[0], iA[1]))
  ax.axvline(x=iB[0], ymax=iB[1]/lim)
  ax.axvline(x=iB[0], ymin=iB[1]/lim, ymax=(iB[1]*(1+(w_o/w_sv)))/lim)
  ax.plot([iA[0], iB[0]],[iA[1], (iA[1] + iB[1])*x])
  ax.annotate('E', (iB[0], (iB[1]+iA[1])*x))
  y0 = -slope([iA[0], iB[0]], [iA[1], iB[1]])*iB[0] + iB[1]*(1+(w_o/w_sv))
  ax.plot([0,iB[0]], [y0, iB[1]*(1+(w_o/w_sv))])
  ax.annotate('A\'', (iB[0],iB[1]*(1+(w_o/w_sv))))
  xp, yp, deg = circle_intersection([iA[0], iB[0]], [iA[1], iB[1]], x1, y1, y0, r)
  ax.plot([org[0], xp], [org[0], yp])
  ax.axvline(x=xp, ymax= yp/lim)
  ax.annotate('P', (xp,yp))
  xq = xp
  yq = ((iB[1]-iA[1])/(iB[0]-iA[0]))*(xp-iA[0])+iA[1]
  ax.annotate('Q', (xq,yq))
  xr = xp
  yr = (((iB[1]-iA[1])/2)/(iB[0]-iA[0]))*(xp-iA[0])+iA[1]
  ax.annotate('R', (xr,yr))
  ax.annotate('S', (xp,iA[1]))
  ax.annotate('T', (xp,0))
  iL = round(np.sqrt(xp**2 + yp**2), 2)
  slip = round((yq-yr)/(yp-yr),3)
  eff = round((yp-yq)/yp, 4) * 100
  pf = round(yp/iL,2)
  xt = lim - 40
  yt = lim - 5
  ax.text(xt, yt, 'Load Current = '+str(iL)+' A', size = 10)
  ax.text(xt, yt-5, 'Slip = '+str(slip), size = 10)
  ax.text(xt, yt-10, 'Efficiency = '+str(eff) + '%', size = 10)
  ax.text(xt, yt-15, 'Power Factor = '+str(pf), size = 10)



